#  二叉树
## 定义
二叉树（Binary）是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和又子树的二叉树组成。
## 二叉树特点
1. 每个结点最多有两棵子树，也就是二叉树不存在度大于2的结点。
2. 二叉树是有序树，左子树和右子树是有顺序的，次序不能任意颠倒。
3. 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
## 二叉树的五种基本形态：
- 空二叉树
- 有一个根结点
- 根结点只有左子树
- 根结点只有右子树
- 根结点既有左子树又有右子树
## 特殊二叉树
### 斜树
斜树顾名思义，斜树一定要是斜的。所有结点都只有左子树的二叉树叫左斜树；所有结点都是只有右子树的二叉树叫右斜树；这两种统称为斜树。

### 满二叉树
满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层次上，这样的二叉树称为满二叉树。
### 完全二叉树
完全二叉树对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
## 二叉树的性质
### 性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i>=1）。


### 性质2： 深度为k的二叉树至多有2^k -1个结点（k>=1）。

### 性质3： 对任何一棵二叉树T，如果其终端结点为n0，度为2的结点数为n2，则n0=n2+1

### 性质4： 具有n个结点的完全二叉树的深度为[log<sub>2</sub><sup>n</sup>] +1，([x] 表示不大于 x 的最大整数)


### 性质5： 如果对一棵有n个结点的完全二叉树（其深度为[log<sub>2</sub><sup>n</sup>]+1）的结点按层序编号（从第1层到第[log<sub>2</sub><sup>n</sup>]+1层，每层从左到右），对任一结点i（1<=i<=n）有： 
1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲的结点[i/2]。
2. 如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。
3. 如果2i+1>n，则结点i无右孩子；否则其右孩子的结点2i+1。

## 二叉树的存储结构
### 二叉树的顺序存储结构
 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点在树的位置跟数组的下标对应起来。 

这种结构，如果对于满二叉树、完全二叉树来说，是比较好，空间利用率高。但对于斜树来说，利用率就非常低了。
### 二叉链表
二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的相反，我们称这样的链表叫做二叉链表。
### 二叉树的遍历
二叉树的遍历（traversing binary tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。
```
         A
        /  \
       B     C
     /      /  \
    D      E    F
  /  \       \
 G    H        I
```
#### 1.前序遍历

若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。遍历顺序为：`ABDGHCEIF`
#### 2.中序遍历

若二叉树为空，则空操作返回，否则中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。遍历顺序为：`GDHBAEICF`
#### 3.后序遍历

若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历左右子树，最后是访问根结点。遍历顺序为：`GHDBIEFCA`
#### 4.层序遍历

若二叉树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。遍历顺序为：`ABCDEFGHI`

## 线索二叉树
把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。

对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。

## 树、森林与二叉树的转换
### 树转换为二叉树

1. 加线。在所有兄弟节点之间加一条线。
2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。 
3. 层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。
### 森林转换为二叉树
1. 把每个树转为二叉树
2. 第一棵二叉树不懂，从第二棵二叉树开始，依次把后一个棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了又森林转换来的二叉树。

### 二叉树转换为树
二叉树转换为树是树转换为二叉树的逆过程。
1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点.... (左孩子的n个右孩子节点都作为此节点的孩子)。将该结点与这些右孩子节点用线连接起来。
2. 去线。删除原二叉树中所有结点与其右孩子结点的连线 
3. 层次调整。使之结构层次分明。
### 二叉树转换为森林
判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树，那么如果是转换成森林，步骤如下：
1.  从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树，
2. 再将每棵分离后的二叉树转换为树即可.
### 树遍历
树的遍历分为两种方式。
1. 一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树.
2.  另一种是后根遍历，即先依次后根遍历毎棵子树，然后再访问根结点。
### 森林遍历

森林的遍历也分为两种方式：
1. 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林

2. 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。

## 赫夫曼树
### 定义
**路径长度**： 从树中一个节点到另一个节点之间的分支构成两个节点之间的路劲，路径上的分支数目称做路径长度

**树的路径长度**就是从树根到每一个结点的路劲长度之和。

**树的带权路径长度**为树中所有叶子节点的带权路径长度之和。

带权路径长度WPL最小的二叉树称做赫夫曼树。（也称最优二叉树）
### 赫夫曼算法
构造赫夫曼树的赫夫曼算法描述：
1. 根据给定的 n 个权值{W1,W2,...,Wn}构成 n 棵二叉树的集合 F ={T1,T2,...,Tn},其中每棵二叉树乃中只有一个带权为 Wi根结点，其左右子树均为空。
2.  在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3.  在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。
4.  重复2和3步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。
### 赫夫曼编码
若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。

一般地，设需要编码的字符集为{d1,d2,...,dn } , 各个字符在电文 中出现的次数或频率集合为{W1,W2,...,Wn},以d1,d2,...,dn作为叶子结点，以W1,W2,...,Wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0,右分支代表1,则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。
