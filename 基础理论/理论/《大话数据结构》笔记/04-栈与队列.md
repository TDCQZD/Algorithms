# 栈与队列
## 栈
### 定义
栈是限定仅在表尾进行插入和删除操作的线性表。

后进先出（Last In First Out）简称为：LIFO 结构。

在这种结构中，我们把允许插入和删除的一端称为栈顶，另一端则称为栈底，没有任何数据时则称为空栈。 
- 插入数据的操作，叫做进栈，也称压栈、入栈。
- 删除操作叫做出栈、也叫做弹栈。
### ADT
```
ADT 栈（stack）
Data
    同线性表。元素具有相同类型，相邻元素具有前驱和后继关系。
Operation
    initStack(*S)：初始化操作，建立一个空栈 S。
    destroyStack(*S)：若栈存在，则销毁它。
    clearStack(*S)：将栈清空。
    stackEmtpy(S)：若栈为空，则返回 true，否则返回 false。
    getTop(S, *e)：若栈存在且非空，用 e 返回栈顶元素。
    push(*S, e)：若栈存在，插入新元素 e 到 S 栈的栈顶。
    pop(*S, e)：若栈存在，删除栈顶元素，并用 e 返回其值。
    stackLength(S)：返回 S 栈中元素的个数。
```
### 存储结构
#### 顺序存储结构
在栈的顺序存储结构中，我们将数组下标为 0 的一端作为栈的栈底。这是因为，栈底的元素变化最小。如果用数组的尾部作为栈底，那么当数组进行扩容时，原数组尾部的元素，就不再是最后一个了。所以我们将数组下标为 0 的一端作为栈底。

另外，我们还定义一个变量：top。我们称它为栈顶指针，用于记录栈顶元素在数组中的位置。

当栈中没有数据时，top 的值为 -1。当有一个元素时，top 的值为 0，有两个元素时，值为 1。top 的大小不能超出栈的长度。若栈的长度为 5，那么 top 的值最大只能为 4。

##### 进栈
##### 出栈
##### 两栈共享空间
如果我们要实现两个相同类型的栈，分别用两个数组来实现，那么就可能会出现，一个栈已经存满、而另一个栈却空很多的情况。

那么这时其实可以用一个数组来实现两个栈，其中一个栈的栈底为数组下标 0 处，另一个栈的栈底是数组另一端，最大下标 -1 处。存储元素时两端都往中间靠拢，以尽量节省空间。

判断是否是空栈，依然是根据栈顶指针来判断。假设 top1 是栈 1 的栈顶指针，top2 是栈 2 的栈顶指针，那么当 top1 = -1 时则表示栈 1 是空栈，当 top2 = 数组的最大长度，则表示栈 2 是空栈。

判断栈满则是根据 top1 + 1 == top2 来判断已经栈满了。

一般使用这种结构，通常都是两个栈的空间需求有相反关系。比如说，股票的买入和卖出。有人买进了，则绝对有另一个人在卖。

#### 链式存储结构
栈的链式存储结构，也简称为：「链栈」。 
##### 进栈
##### 出栈

### 作用
栈这种数据结构的引入，简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决问题的核心。
### 应用
- 递归
- 四则运算表达式求值

## 队列
### 定义
队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
### ADT
```
ADT 队列（Queue）
Data
        同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
        initQueue(*Q)：初始化，建立一个空队列 Q。
        destroyQueue(*Q)：若队列 Q 存在，销毁它。
        clearQueue(*Q)：将队列 Q 清空。
        queueEmpty(Q)：若队列 Q 为空，则返回 true，否则返回 false。
        getHead(Q, *e)：若队列 Q 存在并不为空，用 e 返回队列 Q 的队头元素。
        enQueue(*Q, *e)：若队列 Q 存在，插入新元素 e 到队列 Q 中并成为队尾元素。
        deQueue(*Q, *e)：删除队列 Q 中队头元素，并用 e 返回其值。
        queueLength(Q)：返回队列 Q 中元素个数。
```
### 存储结构
#### 顺序存储结构
队列的顺序存储结构有一个不足。

入队列操作其实就是在队尾追加一个元素，不需要移动任何元素，时间复杂度为O(1);

出队列操作，队列中所有的元素都得向前移动，以保证队列的对头位置不变，时间复杂度为O(n);

为了避免出队列时需要移动后续所有元素，我们可以用循环队列来解决。

##### 循环队列
循环队列：队列头尾相接的顺序存储结构称为循环队列。


为了实现一个循环队列，我们并不需要限制队头在数组下标 0 的位置。我们可以引入两个指针，分别为 front 指针，指向队头元素，rear 指针，指向队尾元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩下一个元素，就是空队列。

当 front 和 rear 指针相等时，既可以是队列已满，也可能是个空队列。该如何区分呢？

有两种方法，一种是设置标志变量 flag，当 flag == 0 并且 front == rear 时，队列为空，当 flag == 1 并且 front == rear 时，队列已满。

另一种是，我们在队列中保留一个元素空间。不填满它。也就说，队列满时，数组中还有一个空闲的单元。 

假设 queueSize 为队列的最大长度，那么队列满的条件是：`(rear + 1) % queueSize == front`。 计算队列长度的公式为：`(rear - front + queueSize) % queueSize`。

##### 入队
##### 出队

#### 链式存储结构
队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。
##### 入队
##### 出队