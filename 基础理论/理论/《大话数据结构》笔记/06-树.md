# 树
## 定义
树（Tree）是 n (n>=0)个节点的有限集。

n = 0 时称为空树。在任意一棵非空树中：
- 有且仅有一个特定的称为根的节点;
- 当 n > 1 时，其余节点可分为 m(m>0) 个互不相交的有限集T1,T2,...,Tn,其中每一个集合本身又是一颗树，并且称为根的子树（SubTree）。
注意：
1. n>0 时，根节点是唯一的，不可能存在多个根节点
2. m>0 时，子树的个数没有限制，但他们一定是互不相交的。
### 节点分类
树的结点包含一个数据元素及若干指向其子树的分支。

**度（Degree）**： 结点拥有的子树数称为结点的度。

**叶结点（Leaf）或终端结点**： 度为0的结点。

**非终端结点或分支结点**：度不为0的结点。
> 除了根节点之外，分支节点也称为内部节点。

**树的度**是树内各节点的度的最大值。

### 节点间的关系
**孩子（child）和双亲（Parent）**：结点的子树的根称为该结点的孩子；相应地，该结点称为孩子的双亲。 

**兄弟（sibling）**：同一个双亲的孩子之间互称兄弟。

**结点的祖先**： 是从根到该结点所经过分支上的所有结点。 

**子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙。
### 树的其他相关概念
**结点的层次（level）**： 结点的层次从根结点开始定义，根为第一层，根的孩子为第二层。

**堂兄弟**：双亲在同一层的结点互为堂兄弟。 

**树的深度（Depth）或高度**：树中结点的最大层次称为树的深度或高度。

**有序树**：树中结点的各子树从左至右是有次序的，不能互换的。 

**无序树**：非有序树。 

**森林（Forest）**：是m(m>=0)棵互不相交的树的集合。


## ADT
```
ADT 树（tree）
Data
    树是一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。   
Operation 
     InitTree(*T);                         //构造空树T
     DestroyTree(*T);                    //销毁树T
     CreateTree(*T,definition);            //按definition中给出树的定义来构造树
     ClearTree(*T);                        //若树T存在，则将树T清为空树  
     TreeEmpty(T);                        //若T为空树，返回true，否则返回false
     TreeDepth(T);                        //返回T的深度
     Root(T);                            //返回T的根结点
     Value(T,cur_e);                        //cur_e是树T中一个节点，返回此结点的值
     Assign(T,cur_e,value);                //给树T的结点cur_e赋值为value
     Parent(T,cur_e);                    //若cur_e是树T的非根结点，则返回它的双亲，否则返回空
     LeftChild(T,cur_e);                    //若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空
     RightSibling(T,cur_e);                //若cur_e有右兄弟，则返回它的右兄弟，否则返回空
     InsertChild(*T,*p,i,c);                //其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树
     DeleteChild(*T,*p,i);                //其中p指向树T的某个结点，i为所指向结点p的度，操作结果为删除T中，p所指结点的第i棵子树

endADT
```
## 存储结构
### 双亲表示法
假设一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示双亲结点的链表中的位置。

双亲表示法的结点结构:
```
/*树的双亲表示法结点结构定义*/
#define MAX_TREE_SIZE 100

typedef int TElemType;      //树节点的数据类型

typedef struct PTNode{                //结点结构
    TElemType data;                    //结点数据
    int parent;                        //双亲位置
} PTNode;

typedef struc{          /*树结构*/
    PTNode node{MAX_TREE_SIZE};        //结点数组
    int r,n;                        //根的位置和结点数
}

```
### 孩子表示法

**多重表表示法**

每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重表表示法。 

多重表表示法的缺点在于，由于每个结点的孩子数是不确定，如果预先在每个结点都开辟好一定的空间来存储指向孩子的指针，则会浪费空间。

**孩子表示法**

把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放一个一维数组中。
### 孩子兄弟表示法
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

## 二叉树