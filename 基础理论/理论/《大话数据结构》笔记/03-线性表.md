# 线性表


## 定义
零个或多个数据元素的有限序列。

**数学语言定义**
![](../images/线性表数学语言定义.png)

在复杂的线性表中，一个数据元素可以由若干个数据项组成。

## 线性表的抽象数据类型

```
ADT 线性表(List)
Data    
    线性表的数据对象集合为{}，每个元素的类型均为DataType。其中，除第一个元素 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    InitList(*L):   初始化操作，建立一个空的线性表L.
    ListEmpty(L):   若线性表为空，返回true，否则则返回false.
    ClearList(*L):  将线性表清空
    GetElem(L,i,*e):    将线性表中的第i个位置元素值返回e。
    LocateElem(L,e):    在线性表L中查找与给定e相等的元素，如果查找成功，则返回该元素在表中序号表示成功；否则返回0表示失败。
    ListInsert(*L,i,e): 在线性表L中的第i个位置插入新元素e。
    ListDelete(*L,i,e): 删除线性表L中第i个位置元素，并用e返回其值。
    ListLength(L):  返回线性表L的元素个数
endADT
```

## 线性表顺序存储
1、定义
线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。
![](../images/list_sequential_storage.png)

2、顺序存储方式

**通常使用一维数组来实现顺序存储结构。**
顺序存储结构的三个属性：
- 存储空间的起始位置：数组Data，它存储位置就是存储空间的存储位置。

- 线性表的最大存储容量：数组长度MaxSize

- 线性表的当前长度：length


## 顺序存储的插入和删除
1. 获得元素操作
    对于线性表的顺序存储结构来说，如果我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回，其实是非常简单的。就程序而言，只要i的数值在数组下标范围内，就是把数组第i一 1下标的值返回即可。
2. 插入操作
    插入算法的思路：
    - 如果插入位置不合理，抛出异常；
    - 如果线性表长度大于等于数组长度，则抛出异常或动态增加容 M ;
    - 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置；
    - 将要插入元素填入位置 i 处；
    - 表长加1。
3. 删除操作
    删除算法的思路：
    - 如果删除位置不合理，抛出异常;
    - 取出删除元素；
    - 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动—个位置；
    - 表长减 1

插入或删除时，时间复杂度为O(n);
### 线性表顺序存储的优缺点
优点：
- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速地存取表中位置的元素
缺点：
- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的"碎片".


## 线性表链式存储
### 定义
为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素 a<sub>i</sub>的存储映像，称为结点（ Node )。

n 个结点（a<sub>i</sub>的存储映像）链结成一个链表，即为线性表（ a<sub>1</sub> , a<sub>2</sub> ,..., a<sub>n</sub>) 的 链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。
#### 结点
结点是有存放数据元素的数据域存放后继结点的指针域组成。

#### 头指针
链表中第一个结点的存储位置叫作头指针。
#### 头结点
单链表的第一个结点前附设一个结点，称为头结点。

#### 区别
头指针：
-  头指针是指链表指向第一个结点的指针，若链表有头结点，则指向头结点的指针
- 头指针具有标识作用，所以常用头指针冠以链表的名字。
- 无论链表是否为空，头指针均不为空。头指针是链表的必要要素。

头结点：
- 头结点是为了操作的统一和方便而设立的，放在第一元素的节点之前，其数据域一般无意义（也可存放链表的长度）
- 有了头结点，对在第一元素节点前插入节点和删除第一节点，其操作与其它节点的操作就统一了。
- 头结点不一定是链表的必要要素

### 链式存储操作
#### 1. 单链表读取
获得链表第 i 个数据的算法思路：
- 声明一个结点 p 指向链表第一个结点，初始化 j 从1开始；
-  当 j < i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点， j 累加1;
-  若到链表末尾 p 为空，则说明第 i 个元素不存在；
-  否则查找成功，返回结点 p 的数据。
#### 2. 单链表插入
单链表第 i 个数据插入结点的算法思路：
- 声明一结点 P 指向链表第一个结点，初始化 j 从1开始；
- 当 j < i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点， j 累加1;
- 若到链表末尾 p 为空，则说明第 i 个元素不存在；
- 否则查找成功，在系统中生成一个空结点 s ;
- 将数据元素 e 赋值给 s -> data ;
- 单链表的插入标准语句 s->next = p->next; p -> next = s ;
-  返回成功。
#### 3. 单链表删除
单链表第 i 个数据删除结点的算法思路：
- 声明一结点 P 指向链表第一个结点，初始化 j 从1开始；
- 当 j < i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点， j 累加1;
- 若到链表末尾 p 为空，则说明第 i 个元素不存在；
- 否则查找成功，将欲删除的节点p->next值给q;
- 单链表的删除标准语句p->next = q->next
- 将q节点中的数据赋值给e,作为返回；
- 是否q节点；
-  返回成功。
#### 4. 单链表整表创建
单链表整表创建的算法思路：
- 声明一节点p和计数器变量i;
- 初始化一空链表L;
- 让L的头结点的指针指向NULL,即建立一个带头的单链表；
- 循环；
    - 生成一新节点赋值给p;
    - 随机生成一数字赋值给判断数据域p->data;
    - 将p插入到头结点与前一节点之间。

#### 5. 单链表整表删除
单链表整表删除的算法思路：
- 声明一节点p和q;
- 将第一个结点赋值给p;
- 循环；
    - 将下一个结点赋值给p;
    - 释放p;
    - 将q赋值给p。
## 线性表链式存储(单链表)与顺序存储结构优缺点
存储分配方式：
- 顺序存储结构用用一段连续的存储单元依次存储数据元素
- 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。
时间性能：
- 查找 
    - 顺序存储结构 O（1）
    - 单链表 O（n）
- 插入和删除 
    - 顺序存储结构需要平均移动表长一半的元素，时间为 O（n）
    - 单链表在找出某位置的指针后，插入和删除时间仅为 O（1）

空间性能：
- 顺序存储结构需要预分配存储空间，分配大了浪费，小了则易发生上溢。
- 单链表不需要预先分配存储空间，只需在使用的时候分配即可，元素个数也没有限制。

## 总结
- 若线性表需要频繁査找，很少进行插入和删除操作时，宜采用顺序存储结构。

- 若需要频繁插入和删除时，宜采用单链表结构。

- 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。

- 如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。

总之，线性表的顺序存储结构和单链表结构各有优缺点，我们需要根据我们的实际情况来运用

## 静态链表
静态链表：用数组描述的链表。

为什么会有静态链表这个东西呢？我们都知道，在 C 语言中有指针、Java 语言中有引用，都可以使我们很方便的操作内存中的地址和数据。但是在早期的编程语言中，如 Basic、Fortra n 等，是没有指针或类似的概念的。那么这时候，像我们上面讲到的链表结构又该如何去实现呢？

之前的大佬们就想出了一个解决方法：用数组来描述链表。

具体的操作就是，让数组的每个元素由两个数据域组成，分别是 data 和 cur。其中 data 代表的是数据元素，cur 则相当于单链表中的 next 指针，存储该元素后继在数组中的下标，我们把 cur 叫做游标。

为了方便插入数据，通常会把数组建立的大一些，以便不容易在插入数据后溢出。

另外通常还会将数组的第一个和最后一个元素作特殊元素处理，不存数据。把没有被使用到的数组元素称为备用链表。而数组的第一个元素，也就是下标为 0 的元素的 cur 就存放备用链表的第一个结点的下标，而数组的最后一个元素的 cur 则存放第一个有数值的元素的下标。
### 静态链表操作
#### 静态链表的插入操作
假设数组中已经存放了 a、c、d 三个元素，其下标分别为 1、2、3。这时候 b 想插入到 a 的后面，这时候只要先把 b 放到现有元素的后面，也就是数组下标为 4 的位置，然后将 a 的 cur 由 2 改为 4，再将 b 的 cur 改为 2，这时候就在不移动元素的情况下，插入了元素 b。
#### 静态链表的删除操作
假设现在要删除 a 元素，那么在删除后数组下标为 1 的位置就空了，所以就需要将下标为 0 元素的 cur 改为 1，让下次的添加，优先从这个位置添加。
### 静态链表优缺点
优点：

- 在插入和删除时，不需要移动元素，只需要修改游标即可。从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的不足。
缺点：

- 没有解决连续存储分配带来的表长难以确定的问题。
- 失去了顺序存储结构随机存储的特性。

总的来说，静态链表其实是为了给没有指针的语言设计的一种实现单链表的思路。在实际的情况中可能会很少用到，但是这种这种巧妙的实现思想倒是值得思考理解。

## 循环链表
循环链表（circular linked list）：将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。
## 双向链表
双向链表（double linked list）：是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中，每个结点除了数据域外，还有两个指针域，分别指向其前驱结点和后继结点。
> 注：在 Java 语言中，LinkedList 的内部实现就是双向链表。

既然单链表可以有循环链表，那么双向链表当然也可以是循环表。想实现一个双向链表的循环表，只需要将其尾结点的 next 指针指向头节点，头节点的 pre 指针指向尾节点即可。

双向链表比单链表多了如可以反向遍历查找数据等优点，那么自然也需要牺牲一些小代价。在插入和删除数据时，需要更改两个指针变量。并且每个结点中多了一个指针域，在空间占用上要稍多一些。