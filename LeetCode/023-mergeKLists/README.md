# 合并K个排序链表
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:
```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```
## 方法 1：暴力
### 思路
1. 遍历所有链表，将所有节点的值放到一个数组中。
2. 将这个数组排序，然后遍历所有元素得到正确顺序的值。
3. 用遍历得到的值，创建一个新的有序链表。
### 复杂度分析

* 时间复杂度：O(NlogN) ，其中 N 是节点的总数目。
  - 遍历所有的值需花费 O(N) 的时间。
  - 一个稳定的排序算法花费O(NlogN) 的时间。
  - 遍历同时创建新的有序链表花费 O(N) 的时间。
* 空间复杂度：O(N)
  - 排序花费 O(N) 空间（这取决于你选择的算法）。
  - 创建一个新的链表花费 O(N)的空间

## 方法 2：逐一比较
### 算法

比较 k 个节点（每个链表的首节点），获得最小值的节点。
将选中的节点接在最终有序链表的后面。
### 复杂度分析

* 时间复杂度： O(kN) ，其中 k 是链表的数目。
  - 几乎最终有序链表中每个节点的时间开销都为 O(k) （k-1 次比较）。
  - 总共有 N 个节点在最后的链表中。
* 空间复杂度：
  - O(n)创建一个新的链表空间开销为 O(n) 。
  - O(1)重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。

## 方法 3：用优先队列优化方法 2
### 复杂度分析

* 时间复杂度：O(Nlogk) ，其中 k 是链表的数目。

  - 弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。
  - 最后的链表中总共有 N 个节点。
* 空间复杂度：
  - O(n) 。创造一个新的链表需要 O(n) 的开销。
  - O(k) 。以上代码采用了重复利用原有节点，所以只要 O(1)的空间。同时优先队列（通常用堆实现）需要 O(k) 的空间（远比大多数情况的 N要小）。


## 方法 4：逐一两两合并链表
### 算法

将合并k 个链表的问题转化成合并 2 个链表 k-1 次。这里是 合并两个有序链表 的题目。

### 复杂度分析

* 时间复杂度： O(kN) ，其中 k 是链表的数目。

  - 可以在 O(n) 的时间内合并两个有序链表，其中 n 是两个链表的总长度。
  - 把所有合并过程所需的时间加起来，我们可以得到：`O(kN) ` 
* 空间复杂度：O(1)
  - 在 O(1) 空间内合并两个有序链表。
## 方法 5：分治
###  算法

这个方法沿用了上面的解法，但是进行了较大的优化。我们不需要对大部分节点重复遍历多次。


### 复杂度分析

* 时间复杂度:O(Nlogk) ，其中 k 是链表的数目。
  - 我们可以在 O(n) 的时间内合并两个有序链表，其中 n 是两个链表中的总节点数。
  - 将所有的合并进程加起来，我们可以得到O(Nlogk) 。
* 空间复杂度：O(1)



