# 209. 长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例: 
```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```
进阶:

* 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。
## 方法一：暴力
### 思路
把所有可能的子数组求和并更新 \text{ans}ans ，直到我们找到最优子数组且和满足 sum≥s
### 算法
- 初始化ans=INT_MAX
- 用变量 i 从左到右遍历数组：
    - 用变量 j 从当前元素到数组尾部遍历：
        - 将 i 到 j 这些元素求和得到 sum
        - 如果和 sum 比 s 大：
            - 更新ans=min(ans,(j−i+1))继续迭代


### 复杂度分析
* 时间复杂度为 时间复杂度：O(n^3)
* 空间复杂度O(1)
## 方法二：优化的暴力
### 思路
在方法 1 中，我们注意到求子数组的和需要的时间为 O(n) 。我们其实可以很容易地实现 O(1) 时间的求和，只需要从开始元素用一个累加器保存和。我们将累积和保存在 sums 中，通过这种方法，我们可以轻松求出任意子区间的和。

### 算法
- 算法流程与方法 1 类似。
- 唯一的不同是求子数组的和：
    - 建立一个大小为 nums 的向量 sums
    - 初始化sums[0]=nums[0]
    - 遍历 向量 sums ：
        - 更新 sums[i]=sums[i−1]+nums[i]
    - 从 ii 到 jj 的和计算方法：

        sum=sums[j]−sums[i]+nums[i] ，其中 sums[j]−sums[i] 是从第 i+1i+1 个元素到第 jj 个元素的和。




### 复杂度分析
* 时间复杂度：O(n^2)
* 空间复杂度O(n)
## 方法三：使用二分查找
### 思路
用二分查找的方法优化方法 2 。我们找到从下标 i 开始满足 sum≥s 的子数组需要 O(n) 的时间。但是我们可以用二分查找的方法把这个时间优化到 O(log(n)) 。在方法 2 中，我们从 i 开始找 j ，直到找到 sum=sums[j]−sums[i]+nums[i] 大于等于s 的。与其线性地查找这个和，我们可以使用二分搜索的方法找到 sums 中不小于 s+sums[i]−nums[i] 的第一个 \sums[j] ，可以用 C++ STL 中的 lower_bound 函数做到。


### 算法
- 创建大小为 n+1n+1 的数组 sumssums ：

    sums[0]=0, sums[i]=sums[i−1]+nums[i−1]

- 从 i=1 到 n 枚举：

    - 在sums 中找到值 to_find ，满足从 i 开始到这个位置的和大于等于 s 且是最小子数组：

    to_find=s+sums[i−1]

    - 在sums 中找到值满足大于等于 to_find的下标，记作bound
    - 如果我们在 sums 中找到了值to_find， 那么：当前子数组的大小为：
    bound - (i-1)
    - 将 ans 与当前数组的大小做比较，并把较小值保存到 ans 中



### 复杂度分析
* 时间复杂度：O(nlog(n)) 。

* 空间复杂度O(n)
## 方法一：双指针
### 思路
案了，我们就可以移动左端点。我们用 2 个指针，一个指向数组开始的位置，一个指向数组最后的位置，并维护区间内的和 sum 大于等于 s 同时数组长度最小。


### 算法
- 初始化 left 指向 0 且初始化 sum 为 0
- 遍历 nums 数组：
    - 将nums[i] 添加到 sum
    - 当 sum 大于等于 s 时：
        - 更新 ans=min(ans,i+1−left) ，其中 i+1−left是当前子数组的长度
        - 然后我们可以移动左端点，因为以它为开头的满足 sum≥s 条件的最短子数组已经求出来了
        - 将 sum 减去nums[left] 然后增加 left



### 复杂度分析
* 时间复杂度：O(n) 。每个指针移动都需要 O(n) 的时间。
* 空间复杂度O(1)