# 环形链表 II
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

 

示例 1：
```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```
![](./circularlinkedlist.png)

示例 2：
```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```
![](./circularlinkedlist_test2.png)

示例 3：
```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

![](./circularlinkedlist_test3.png)

## 方法一：哈希表

### 思路

如果我们用一个HashTable保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。

### 复杂度分析

* 时间复杂度：O(n)

    不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 n 个节点指向 null ，这会让循环退出。对于循环列表， if 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 n 个，所以运行时间跟节点数目成线性关系。

* 空间复杂度：O(n)

    不管成环或者不成欢的输入，我们都需要将每个节点插入 Set 中一次。两者唯一的区别是最后访问的节点后是 null 还是一个已经访问过的节点。因此，由于 Set 包含 n 个不同的节点，所需空间与节点数目也是线性关系的。

## 方法 2：Floyd 算法
### 思路：

当然一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。

### 算法

Floyd 的算法被划分成两个不同的 阶段 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 null 并退出。否则，用 相遇节点 来找到环的入口。

### 复杂度分析

* 时间复杂度：O(n)
* 空间复杂度：O(1)

