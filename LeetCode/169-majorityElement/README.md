# 求众数
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:
```
输入: [3,2,3]
输出: 3
```
示例 2:
```
输入: [2,2,1,1,1,2,2]
输出: 2
```
## 方法 1：暴力
想法

我们可以在平方级的时间里穷举所有情况，来检测每个数是不是众数。

算法

暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。
复杂度分析

时间复杂度：O(n^2)
 空间复杂度：O(1)

方法 2：哈希表
想法

我们知道出现次数最多的元素大于 n/2 次，所以可以用哈希表来快速统计每个元素出现的次数。

算法

我们使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。
复杂度分析

时间复杂度：O(n)
空间复杂度：O(n)

方法 3：排序
想法

如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为 n/2(当n为偶数时，下标为n/2+1)
算法
无论众数是多少，返回n/2下标对应的值都是正确的。
复杂度分析

时间复杂度：O(nlgn)
空间复杂度：O(1)O(1) 或者 O(n)O(n)

方法 4：随机化
想法

因为超过 n/2 的数组下标被众数占据了，一个随机的下标很有可能存有众数。

算法

由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它的值是否是众数，如果是就返回，否则继续随机挑选。
复杂度分析

时间复杂度：O(∞)
空间复杂度：O(1)
方法 5：分治
想法

如果我们知道数组左边一半和右边一半的众数，我们就可以用线性时间知道全局的众数是哪个。

算法

这里我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。由于传输子数组需要额外的时间和空间，所以我们实际上只传输子区间的左右指针 lo 和 hi 表示相应区间的左右下标。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1 ，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。原问题的答案就是下标为 00 和 nn 之间的众数这一子问题。
复杂度分析

时间复杂度：O(nlgn)
空间复杂度：O(lgn)
方法 6：Boyer-Moore 投票算法
想法

如果我们把众数记为 +1+1 ，把其他数记为 -1−1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。