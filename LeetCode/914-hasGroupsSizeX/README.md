# 914. 卡牌分组
给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：

- 每组都有 X 张牌。
- 组内所有的牌上都写着相同的整数。
- 仅当你可选的 X >= 2 时返回 true。

 

示例 1：
```
输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
```
示例 2：
```
输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
```
示例 3：
```
输入：[1]
输出：false
解释：没有满足要求的分组。
```
示例 4：
```
输入：[1,1]
输出：true
解释：可行的分组是 [1,1]
```
示例 5：
```
输入：[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]
```
提示：

* 1 <= deck.length <= 10000
* 0 <= deck[i] < 10000
 

## 方法 1：暴力
### 思路

尝试所有可行的 X。

### 算法

由于我们要将 N 张卡片分成 K 堆每堆 X 张，一定有 N % X == 0。

那么，假设有 C_i 张写有数字 i 的卡片，每组数字 i 卡片有 X 张，那么一定有 C_i % X == 0。这是一个充要条件。


### 复杂度分析

* 时间复杂度：O(N^2loglogN)，其中 N 是卡片个数。本文不证明找到所有 N 的因数个数的上界是 O(NloglogN)。
* 空间复杂度：O(N)。
## 方法 2：最大公约数
### 思路

同理假设 C_i 是数字 i 的卡片个数，同样对于所有的 i 满足 C_i % X == 0，其中每堆有 X 张卡片。

因此，X 一定可以整除 C_i 的最大公约数。如果最大公约数 g 超过 1，那么就有 X = g 满足条件，否则不满足条件。

### 算法
### 复杂度分析

* 时间复杂度：O(N log^2 N)O，其中 N 是卡片的个数。假设数字 i 有 C_i张，那么每次 gcd 操作的复杂度是 O(log^2 C_i)。存在更优的上界，但不在本文的考虑范围内。
* 空间复杂度：O(N)。
