## 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0] 
```
## 方法一：暴力法
### 思路
首先遍历一遍数列，用另个数列按顺序存储所有非 0 的元素，在将存储的非零元素按顺序复制到原数列中，空位补 0 即可。
### 算法
### 复杂度分析
* 时间复杂度：O(n)
* 空间复杂度：O(n)
## 方法二：双指针
### 思路
1. 慢指针（lastnonzerofoundat）之前的所有元素都是非零的。

2. 当前指针和慢速指针之间的所有元素都是零。

3. 当我们遇到一个非零元素时，我们需要交换当前指针和慢速指针指向的元素，然后前进两个指针。如果它是零元素，我们只前进当前指针。
### 算法
### 复杂度分析

* 时间复杂度：O(n)。但是，操作是最优的。代码执行的总操作（数组写入）是非 0 元素的数量。这比上一个解决方案的复杂性（当大多数元素为 0 时）要好得多。但是，两种算法的最坏情况（当所有元素都为非 0 时）复杂性是相同的。
* 空间复杂度：O(1)，只使用了常量空间。

## 方法三：置零
### 思路
1. 设置零指针p,循环数组
2. 当前i非零,nums[p]=nums[i]
3. `p<len(nums)`,p到len(nums)设置值为零0
### 算法
### 复杂度分析
* 时间复杂度：O(n)
* 空间复杂度：O(1)